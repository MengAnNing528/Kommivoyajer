//Реализация графа
#include "Graph.h"

Graph::Graph() {
    this->n = 5;
    data = new int*[5];
    for (int i = 0; i < 5; i++) {
        data[i] = new int[5];
    }

    // граф по умолчанию
    data[0][0] = 0;    data[0][1] = 2;    data[0][2] = -1;    data[0][3] = 3;    data[0][4] = -1;
    data[1][0] =2;     data[1][1] = 0;    data[1][2] = 4;     data[1][3] = 4;    data[1][4] = -1;
    data[2][0] = -1;   data[2][1] = 4;    data[2][2] = 0;     data[2][3] = 5;    data[2][4] = 6;
    data[3][0] = 3;    data[3][1] = 4;    data[3][2] = 5;    data[3][3] = 0;    data[3][4] = -1;
    data[4][0] = -1;   data[4][1] = -1;   data[4][2] = 6;     data[4][3] = -1;   data[4][4] = 0;
}

// создание графа с n вершинами
Graph::Graph(int n) {
    this->n = n;
    data = new int*[n];
    for (int i = 0; i < n; i++) {
        data[i] = new int[n];
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            cout << "Input " << i << '-' << j << ": ";
            cin >> data[i][j];
            data[j][i] = data[i][j];
        }
    }
}

// данные о графе
int** Graph::Get_data() const {
    int** d = new int*[n];
    for (int i = 0; i < n; ++i) {
        d[i] = new int[n];
        for (int j = 0; j < n; ++j) {
            d[i][j] = data[i][j];
        }
    }
    return d;
}

// количество вершин графа
int Graph::Get_n() const { return n; }

// вывод графа
ostream& operator<<(ostream& os, const Graph& g) {
    int** d = g.Get_data();
    
    for (int i = 0; i < g.Get_n(); i++) {
        for (int j = 0; j < g.Get_n(); j++) {
            os << setw(4) << d[i][j] << ' ';
        }
        os << endl;
    }
    return os;
}

//Реализвция пути
#include "Path.h"

Path::Path(int start) {
    path.push_back(start);
    length = 0;
}

Path& Path::operator=(const Path& p) {
    path = p.Get_path();
    length = p.Get_length();
    return *this;
}

// путь
vector<int> Path::Get_path() const { return path; }

// длина пути
int Path::Get_length() const { return length; }

// добавление вершины в конец
void Path::push_back(int v, int l) {
    path.push_back(v);
    length += l;
}

// добавление пути в конец
void Path::push_back(Path p) {
    for (size_t i = 0; i < p.Get_path().size(); ++i) {
        int last = path[path.size() - 1];
        if (last != p.Get_path()[i]) {
            path.push_back(p.Get_path()[i]);
        }
    }
    length += p.Get_length();
}

ostream& operator<<(ostream& os, const Path& p) {
    size_t n = p.Get_path().size();
    for (size_t i = 0; i < n; i++) {
        os << p.Get_path()[i] + 1;
        if (i != n - 1) {
            os << "->";
        } else {
            os << " (";
        }
    }
    os << p.Get_length() << ')' << endl;
    return os;
}

//Алгоритм Дейкстры
#include "Solution.h"

Solution::Solution(const Graph& g) {
    graph = g;
}

// алгоритм Дейкстры
Path* Solution::Dijkstra(int v, Path* data) {
    data = (Path*)calloc(graph.Get_n(), sizeof(Path));      //пути от вершины v до других вершин графа
    int distaces[graph.Get_n()];                            //минимальное расстояние от вершины v до других
    int out[graph.Get_n()];                                 //посещенные вершины
    for (int i = 0; i < graph.Get_n(); ++i) {
        if (i == v) {
            distaces[i] = 0;
            data[i] = Path(v);
        } else {
            distaces[i] = numeric_limits<int>::max();
        }
        out[i] = 0;
    }

    int min = numeric_limits<int>::max(), index = -1;
    do {
        min = numeric_limits<int>::max();
        for (int i = 0; i < graph.Get_n(); ++i) {
            if ((out[i] == 0) && (distaces[i] < min)) {
                min = distaces[i];
                index = i;
            }
        }
        if (min != numeric_limits<int>::max()) {
            for (int i = 0; i < graph.Get_n(); ++i) {
                if (graph.Get_data()[index][i] > 0) {
                    int temp = min + graph.Get_data()[index][i];
                    if (temp < distaces[i]) {
                        distaces[i] = temp;
                        data[i] = data[index];
                        data[i].push_back(i, graph.Get_data()[index][i]);
                    }
                }
            }
            out[index] = 1;
        }
    } while (min < numeric_limits<int>::max());

    return data;
}

// вычисление оптимального пути
Path Solution::calc(vector<int> v, int start) {
    map<int, Path*> distaces;
    Path* temp = (Path*)calloc(graph.Get_n(), sizeof(Path));
    temp = Dijkstra(start, temp);
    distaces[start] = temp;
    for (size_t i = 0; i < v.size(); ++i) {
        temp = Dijkstra(v[i], temp);
        distaces[v[i]] = temp;
    }

    Path p = Path(start);
    sort(v.begin(), v.end());
    for (size_t i = 0; i < v.size(); ++i) {
        int last = p.Get_path()[p.Get_path().size() - 1];
        p.push_back(distaces[last][v[i]]);
    }
    int last = p.Get_path()[p.Get_path().size() - 1];
    p.push_back(distaces[last][start]);
    next_permutation(v.begin(), v.end());

    do {
        Path temp = Path(start);
        for (size_t i = 0; i < v.size(); ++i) {
            int last = temp.Get_path()[temp.Get_path().size() - 1];
            temp.push_back(distaces[last][v[i]]);
            if (temp.Get_length() > p.Get_length())
                break;
        }
        int last = temp.Get_path()[temp.Get_path().size() - 1];
        temp.push_back(distaces[last][start]);

        if (temp.Get_length() < p.Get_length()) {
            p = temp;
        }
    } while (next_permutation(v.begin(), v.end()));

    return p;
}
